<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Opération tempête</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
        color: #e2e8f0;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        min-height: 100vh;
        padding: 24px;
      }
      .layout {
        display: flex;
        gap: 18px;
        width: 100%;
        max-width: 1080px;
        align-items: flex-start;
      }
      .card {
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(226, 232, 240, 0.1);
        border-radius: 16px;
        padding: 24px;
        width: 100%;
        box-shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
      }
      .cart {
        width: 320px;
        min-height: 160px;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(226, 232, 240, 0.1);
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
        position: sticky;
        top: 16px;
      }
      .cart h2 {
        margin: 0 0 10px 0;
        font-size: 18px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .cart-count {
        font-size: 12px;
        color: #cbd5e1;
      }
      .cart-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .cart-item {
        padding: 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(226, 232, 240, 0.08);
        display: flex;
        justify-content: space-between;
        gap: 10px;
        align-items: center;
      }
      .cart-item-title {
        font-weight: 700;
        color: #f8fafc;
        font-size: 14px;
      }
      .cart-item-meta {
        font-size: 12px;
        color: #cbd5e1;
      }
      .cart-remove {
        width: 60px;
        background: transparent;
        color: #f43f5e;
        border: 1px solid transparent;
        border-radius: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        font-size: 14px;
        cursor: pointer;
      }
      .cart-empty {
        color: #94a3b8;
        font-size: 13px;
      }
      .cart-subscribe {
        margin-top: 14px;
        padding-top: 12px;
        border-top: 1px solid rgba(226, 232, 240, 0.08);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .cart-subscribe input {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(226, 232, 240, 0.2);
        background: rgba(255, 255, 255, 0.06);
        color: #e2e8f0;
        font-size: 14px;
      }
      .cart-subscribe button {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: none;
        background: linear-gradient(120deg, #fbbf24, #f59e0b);
        color: #0f172a;
        font-weight: 700;
        cursor: pointer;
      }
      h1 {
        margin: 0 0 12px 0;
        font-size: 28px;
        letter-spacing: 0.5px;
      }
      p {
        margin: 0 0 18px 0;
        line-height: 1.6;
        color: #cbd5e1;
      }
      button {
        appearance: none;
        border: none;
        border-radius: 10px;
        padding: 12px 18px;
        font-size: 16px;
        font-weight: 600;
        color: #0f172a;
        background: linear-gradient(120deg, #fbbf24, #f59e0b);
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
        width: 100%;
      }
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
        filter: brightness(1.05);
      }
      button:active {
        transform: translateY(0);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
      }
      .note {
        margin-top: 12px;
        font-size: 14px;
        color: #94a3b8;
      }
      .field {
        display: flex;
        gap: 12px;
        margin: 18px 0 8px 0;
        flex-wrap: wrap;
        position: relative;
      }
      .field input {
        flex: 1;
        min-width: 240px;
        padding: 12px 14px;
        border-radius: 10px;
        border: 1px solid rgba(226, 232, 240, 0.2);
        background: rgba(255, 255, 255, 0.06);
        color: #e2e8f0;
        font-size: 16px;
        outline: none;
      }
      .field input:focus {
        border-color: #fbbf24;
        box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.25);
      }
      .suggestions {
        position: absolute;
        top: 56px;
        left: 0;
        right: 0;
        z-index: 5;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(226, 232, 240, 0.12);
        border-radius: 10px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        overflow: hidden;
      }
      .suggestion-item {
        padding: 10px 14px;
        cursor: pointer;
        color: #e2e8f0;
        border-bottom: 1px solid rgba(226, 232, 240, 0.07);
      }
      .suggestion-item:last-child {
        border-bottom: none;
      }
      .suggestion-item:hover {
        background: rgba(226, 232, 240, 0.08);
      }
      .results {
        margin-top: 16px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(226, 232, 240, 0.05);
      }
      .result-item {
        position: relative;
        padding: 18px 18px;
        padding-right: 100px; /* leave room for the button */
        border-bottom: 1px solid rgba(226, 232, 240, 0.07);
      }
      .result-item.no-border {
        border-bottom: none;
        padding-bottom: 18px;
      }
      .result-item:last-child {
        border-bottom: none;
      }
      .result-title {
        font-weight: 700;
        color: #f8fafc;
        margin: 0 0 8px 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .result-meta {
        color: #cbd5e1;
        font-size: 14px;
        line-height: 1.5;
      }
      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.05);
      }
      .status-open {
        background: linear-gradient(135deg, #22c55e, #16a34a);
      }
      .status-off {
        background: linear-gradient(135deg, #f43f5e, #e11d48);
      }
      .status-unknown {
        background: linear-gradient(135deg, #94a3b8, #64748b);
      }
      .add-btn {
        position: absolute;
        right: 12px;
        top: 10px;
        bottom: 10px;
        width: 80px;
        background: transparent;
        border: 1px solid transparent;
        color: #fbbf24;
        border-radius: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        font-size: 14px;
        cursor: pointer;
      }
      .add-btn:disabled {
        opacity: 0.5;
        cursor: default;
      }
      .add-btn.add-plus {
        font-size: 20px;
        font-weight: 800;
      }
      .add-btn.added {
        font-size: 12px;
      }
      .divider {
        border-top: 2px solid #fbbf24;
        margin: 8px 0 4px 0;
        opacity: 0.9;
      }
      .options {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 6px;
        color: #cbd5e1;
        font-size: 14px;
      }
      .options input[type="number"] {
        width: 90px;
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(226, 232, 240, 0.2);
        background: rgba(255, 255, 255, 0.06);
        color: #e2e8f0;
      }
      .options input[type="number"]:focus {
        border-color: #fbbf24;
        outline: none;
        box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.2);
      }
      .debug {
        margin-top: 12px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px dashed rgba(226, 232, 240, 0.2);
        font-size: 12px;
        color: #cbd5e1;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="card">
        <h1>Opération Tempête</h1>
        <p>
          Entre ton adresse (rue, code postal ou no civique) pour voir l’état des
          lumières de déneigement les plus proches (données officielles ArcGIS).
        </p>
        <div class="field">
          <input
            id="addressInput"
            type="text"
            placeholder="Ex.: 121 Avenue Gauvin, Québec G1M 1Y3"
          />
          <button id="statusButton" type="button">Voir le statut</button>
          <div id="suggestions" class="suggestions" style="display: none"></div>
        </div>
        <label class="options">
          <input type="checkbox" id="nearbyToggle" />
          Inclure les feux des rues avoisinantes
          <input
            type="number"
            id="radiusInput"
            min="50"
            max="1000"
            step="50"
            value="200"
            aria-label="Rayon de recherche en mètres"
          />
          <span>m</span>
        </label>
        <div class="results" id="results"></div>
        <div id="debugPanel" class="debug" style="display: none"></div>
      </div>

      <div class="cart">
        <h2>
          Sélection
          <span class="cart-count" id="cartCount">(0)</span>
        </h2>
        <div class="cart-list" id="cartList">
          <div class="cart-empty">Faites une sélection pour poursuivre</div>
        </div>
        <div class="cart-subscribe" id="subscribeSection">
          <input
            type="tel"
            id="phoneInput"
            placeholder="Numéro de téléphone"
            aria-label="Numéro de téléphone"
          />
          <button id="subscribeButton" type="button">S'abonner</button>
          <div id="subscribeMessage" class="cart-empty" style="display: none"></div>
        </div>
      </div>
    </div>

    <script>
      const DEBUG = false;
      const featureLayerUrl =
        "https://services1.arcgis.com/4GCvRJNX6LNyFVQ0/ArcGIS/rest/services/CI_OPERATION_DENEIGEMENT/FeatureServer/0/query";
      const statusButton = document.getElementById("statusButton");
      const addressInput = document.getElementById("addressInput");
      const resultsDiv = document.getElementById("results");
      const suggestionsDiv = document.getElementById("suggestions");
      const debugPanel = document.getElementById("debugPanel");
      const nearbyToggle = document.getElementById("nearbyToggle");
      const radiusInput = document.getElementById("radiusInput");
      let selectedSuggestion = null;
      let suggestionAbort = null;
      let postsCache = null;
      const cart = new Map();

      function haversine(lat1, lon1, lat2, lon2) {
        const toRad = (d) => (d * Math.PI) / 180;
        const R = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      function statusClass(status) {
        const s = (status || "").toLowerCase();
        // Map known statuses: éteint → green, en fonction/ouvert/allumé → red, hors service → gray
        if (s.includes("hors")) return "status-unknown";
        if (s.includes("éteint") || s.includes("eteint")) return "status-open";
        if (s.includes("fonction") || s.includes("ouvert") || s.includes("allum"))
          return "status-off";
        return "status-unknown";
      }

      async function loadPosts() {
        if (postsCache) return postsCache;
        const res = await fetch("posts.csv");
        if (!res.ok) throw new Error("Impossible de charger le fichier des postes");
        const text = await res.text();
        function parseCSV(csvText) {
          const rows = [];
          let row = [];
          let field = "";
          let inQuotes = false;
          for (let i = 0; i < csvText.length; i++) {
            const c = csvText[i];
            if (c === '"' && csvText[i + 1] === '"') {
              field += '"';
              i++;
            } else if (c === '"') {
              inQuotes = !inQuotes;
            } else if (c === "," && !inQuotes) {
              row.push(field);
              field = "";
            } else if ((c === "\n" || c === "\r") && !inQuotes) {
              if (c === "\r" && csvText[i + 1] === "\n") i++;
              row.push(field);
              rows.push(row);
              row = [];
              field = "";
            } else {
              field += c;
            }
          }
          if (field.length > 0 || row.length) {
            row.push(field);
            rows.push(row);
          }
          return rows.filter((r) => r.length);
        }

        const rawRows = parseCSV(text.trim());
        const header = rawRows[0];
        const dataRows = rawRows.slice(1).map((cols) => {
          if (cols.length < header.length) {
            return cols.concat(Array(header.length - cols.length).fill(""));
          }
          if (cols.length > header.length) {
            const fixed = cols.slice(0, header.length - 1);
            fixed.push(cols.slice(header.length - 1).join(","));
            return fixed;
          }
          return cols;
        });
        const idx = (name) => header.indexOf(name);
        const stationIdx = idx("STATION_NO");
        const statusIdx = idx("STATUT");
        const dateIdx = idx("DATE_MAJ_ISO");
        const streetIdx = idx("RUE_REVERSE");
        const lonIdx = idx("LON_WGS84");
        const latIdx = idx("LAT_WGS84");
        const xIdx = idx("X_32187");
        const yIdx = idx("Y_32187");

        const parseNum = (val) => {
          if (val == null) return null;
          const cleaned = String(val).replace(/"/g, "").trim();
          const parsed = parseFloat(cleaned);
          return Number.isFinite(parsed) ? parsed : null;
        };

        postsCache = dataRows.map((cols) => {
          const street = cols[streetIdx];
          const lonVal = parseNum(cols[lonIdx]);
          const latVal = parseNum(cols[latIdx]);
          const xVal = parseNum(cols[xIdx]);
          const yVal = parseNum(cols[yIdx]);
          return {
            station: cols[stationIdx],
            statut: cols[statusIdx],
            dateMaj: cols[dateIdx],
            street,
            normStreet: canonicalStreet(street),
            lon: lonVal,
            lat: latVal,
            x: xVal,
            y: yVal,
          };
        });
        return postsCache;
      }

      const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      function logDebug(title, payload) {
        if (!DEBUG) return;
        const now = new Date().toISOString();
        const existing = debugPanel.textContent
          ? `${debugPanel.textContent}\n`
          : "";
        const content = `${existing}[${now}] ${title}: ${JSON.stringify(
          payload,
          null,
          2
        )}`;
        debugPanel.textContent = content;
        debugPanel.style.display = "block";
        console.info(title, payload);
      }

      async function geocode(queryText, magicKey) {
        const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates?f=pjson&maxLocations=1&singleLine=${encodeURIComponent(
          queryText
        )}${magicKey ? `&magicKey=${encodeURIComponent(magicKey)}` : ""}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Geocodage indisponible");
        const data = await res.json();
        const candidate = data.candidates?.[0];
        if (!candidate) throw new Error("Adresse introuvable");
        logDebug("geocode", {
          address: candidate.address,
          attributes: candidate.attributes,
          location: candidate.location,
        });
        return {
          location: candidate.location, // {x: lon, y: lat}
          address: candidate.address,
          streetHint:
            canonicalStreet(candidate.address) ||
            canonicalStreet(
              candidate.attributes?.StreetName || candidate.attributes?.StName
            ),
        };
      }

      async function projectToSR(points, inSR, outSR) {
        if (!points.length) return [];
        const geometries = encodeURIComponent(
          JSON.stringify({
            geometryType: "esriGeometryPoint",
            geometries: points,
          })
        );
        const url = `https://utility.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer/project?f=pjson&geometries=${geometries}&inSR=${inSR}&outSR=${outSR}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Transformation de coordonnées échouée");
        const data = await res.json();
        logDebug("projectToSR", {
          inSR,
          outSR,
          points,
          resultCount: (data.geometries || []).length,
        });
        return data.geometries || [];
      }

      function normalizeStreet(text) {
        if (!text) return null;
        const base = text
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "");
        const first = base.split(",")[0];
        // Remove leading address numbers/ranges (ex: "103-151 av gauvin") but keep numbered street names (ex: "5e avenue")
        const cleaned = first
          .replace(/^[0-9]+(\s*-\s*[0-9]+)?\s+/, "")
          .replace(/\s+/g, " ")
          .trim();
        return cleaned || null;
      }

      function canonicalStreet(text) {
        const n = normalizeStreet(text);
        if (!n) return null;
        let c = n;
        c = c.replace(/^av(\.|enue)?\s+/, "avenue ");
        c = c.replace(/^ave\s+/, "avenue ");
        c = c.replace(/^av-/ , "avenue ");
        c = c.replace(/^boul(\.|evard)?\s+/, "boulevard ");
        c = c.replace(/^rte\s+/, "route ");
        c = c.replace(/^chem(in)?\s+/, "chemin ");
        c = c.replace(/^r(\.|ue)?\s+/, "rue ");
        c = c.replace(/\s+/g, " ").trim();
        return c;
      }

      function addressOrderKey(post) {
        const street = post.normStreet || "";
        const raw = post.street || "";
        const match = raw.match(/(\d+)/);
        const num = match ? parseInt(match[1], 10) : Number.MAX_SAFE_INTEGER;
        const stationNum = parseInt(post.station, 10);
        return {
          street,
          num,
          station: Number.isNaN(stationNum) ? Number.MAX_SAFE_INTEGER : stationNum,
        };
      }

      const addressCache = new Map();
      async function reverseGeocode4326(point) {
        if (!point) return null;
        const key = `${point.x.toFixed(5)},${point.y.toFixed(5)}`;
        if (addressCache.has(key)) return addressCache.get(key);
        const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?f=pjson&featureTypes=StreetAddress&langCode=fr&location=${point.x},${point.y}`;
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error("reverse geocode failed");
          const data = await res.json();
          const label =
            data.address?.LongLabel ||
            data.address?.Address ||
            data.address?.Match_addr ||
            null;
          addressCache.set(key, label);
          return label;
        } catch (e) {
          addressCache.set(key, null);
          return null;
        }
      }

      function renderSuggestions(list) {
        if (!list.length) {
          suggestionsDiv.style.display = "none";
          suggestionsDiv.innerHTML = "";
          return;
        }
        suggestionsDiv.innerHTML = list
          .map(
            (item) =>
              `<div class="suggestion-item" data-magic="${item.magicKey}" data-text="${item.text}">${item.text}</div>`
          )
          .join("");
        suggestionsDiv.style.display = "block";
      }

      function formatDate(ms) {
        return ms ? new Date(ms).toLocaleString("fr-CA") : "N/D";
      }

      function formatMeters(m) {
        if (m == null) return "distance inconnue";
        if (m >= 1000) return `${(m / 1000).toFixed(1)} km`;
        return `${Math.round(m)} m`;
      }

      function renderStatus(message, items = []) {
        if (!items.length) {
          resultsDiv.innerHTML = `<p class="note">${message}</p>`;
          return;
        }
        const isInCart = (station) => cart.has(String(station));
        let html = "";
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const next = items[i + 1];
          const classNames =
            next && next.group !== item.group
              ? "result-item no-border"
              : "result-item";
          const addDisabled = isInCart(item.stationNo);
          const addLabel = addDisabled ? "Ajouté" : "+";
          const addClass = addDisabled ? "add-btn added" : "add-btn add-plus";
          html += `
            <div class="${classNames}">
              <div class="result-title">
                <span class="status-dot ${item.dotClass}"></span>
                Feu ${item.statut}
                <button class="${addClass}" data-station="${item.stationNo}" ${addDisabled ? "disabled" : ""}>
                  ${addLabel}
                </button>
              </div>
              <div class="result-meta">
                Poste : ${item.stationNo ?? "N/D"} — Distance : ${item.distance}
                <br />
                Emplacement : ${item.locationLabel}
                <br />
                Dernière mise à jour : ${item.updated}
              </div>
            </div>
          `;
          if (next && next.group !== item.group) {
            html += `<div class="divider"></div>`;
          }
        }
        resultsDiv.innerHTML = html;
      }

      let currentItems = [];

      async function fetchStatuses() {
        const query = addressInput.value.trim();
        if (!query) {
          renderStatus("Entre une adresse ou un code postal.");
          return;
        }
        renderStatus("Recherche en cours...");
        statusButton.disabled = true;
        try {
          const normalizedInput = canonicalStreet(query);
          const includeNearby = nearbyToggle.checked;
          const radiusMeters = Math.max(
            50,
            Math.min(1000, Number.parseInt(radiusInput.value, 10) || 200)
          );
          const posts = await loadPosts();

          let address = query;
          let location = null;
          try {
            const geo = await geocode(query, selectedSuggestion?.magicKey);
            address = geo.address;
            location = geo.location; // {x: lon, y: lat}
          } catch (e) {
            console.warn("Geocode failed, fallback to street-only", e);
          }

          let filtered = posts.filter((p) => p.normStreet === normalizedInput);

          if (includeNearby && location) {
            const buffer = radiusMeters;
            const nearby = posts.filter((p) => {
              if (p.lat == null || p.lon == null) return false;
              const d = haversine(location.y, location.x, p.lat, p.lon);
              return d <= buffer;
            });
            const merged = new Map();
            [...filtered, ...nearby].forEach((p) => merged.set(p.station, p));
            filtered = Array.from(merged.values());
          }

          if (!filtered.length) {
            renderStatus(
              `Aucun feu trouvé pour “${address}”. Essaie d'entrer le nom complet de la rue.`
            );
            return;
          }

          const stations = filtered.map((p) => p.station).filter(Boolean);
          let statusMap = {};
          if (stations.length) {
            const list = stations.map((s) => `'${s}'`).join(",");
            const url = `${featureLayerUrl}?f=pjson&where=STATION_NO%20IN%20(${list})&outFields=STATION_NO,STATUT,DATE_MAJ&returnGeometry=false`;
            const res = await fetch(url);
            if (res.ok) {
              const data = await res.json();
              (data.features || []).forEach((f) => {
                const a = f.attributes || {};
                statusMap[a.STATION_NO] = {
                  statut: a.STATUT,
                  dateMaj: a.DATE_MAJ ? formatDate(a.DATE_MAJ) : "N/D",
                };
              });
            }
          }

          let origin = null;
          // Origin priority: geocoded point first, otherwise a feu on the street, otherwise any feu with coords
          const firstPrimary = filtered.find(
            (p) => p.normStreet === normalizedInput && p.lat != null && p.lon != null
          );
          if (location && location.x != null && location.y != null) {
            origin = { lon: location.x, lat: location.y };
          } else if (firstPrimary) {
            origin = { lon: firstPrimary.lon, lat: firstPrimary.lat };
          } else {
            const any = filtered.find((p) => p.lat != null && p.lon != null);
            if (any) origin = { lon: any.lon, lat: any.lat };
          }

          const withDist = filtered.map((p) => {
            let dist = null;
            if (origin && p.lat != null && p.lon != null) {
              dist = haversine(origin.lat, origin.lon, p.lat, p.lon);
            }
            const live = statusMap[p.station] || {};
            const statut = live.statut || p.statut || "Inconnu";
            const updated = live.dateMaj ?? "N/D"; // date privilégiée du service; pas de repli CSV
            return { ...p, dist, statut, dateMaj: updated, dotClass: statusClass(statut) };
          });

          const primary = withDist.filter((p) => p.normStreet === normalizedInput);
          const others = withDist.filter((p) => p.normStreet !== normalizedInput);

          primary.sort((a, b) => (a.dist ?? Infinity) - (b.dist ?? Infinity));
          others.sort((a, b) => (a.dist ?? Infinity) - (b.dist ?? Infinity));

          const toItems = (list, group) =>
            list.map((p) => ({
              statut: (p.statut || "Inconnu").toLowerCase(),
              updated: p.dateMaj,
              stationNo: p.station,
              distance:
                p.dist != null && Number.isFinite(p.dist) ? formatMeters(p.dist) : "N/D",
              locationLabel: p.street || "emplacement inconnu",
              dotClass: p.dotClass,
              group,
            }));

          const items = includeNearby
            ? [...toItems(others, "nearby"), ...toItems(primary, "primary")]
            : toItems(primary, "primary");

          currentItems = items;
          renderStatus(`Adresse : ${address}.`, items);
        } catch (error) {
          renderStatus(
            "Impossible de récupérer le statut pour le moment. Réessaie plus tard ou vérifie l’adresse."
          );
          console.error(error);
        } finally {
          statusButton.disabled = false;
        }
      }

      statusButton.addEventListener("click", fetchStatuses);
      addressInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          fetchStatuses();
        }
      });
      resultsDiv.addEventListener("click", (e) => {
        const btn = e.target.closest(".add-btn");
        if (!btn) return;
        const station = btn.getAttribute("data-station");
        if (!station) return;
        if (cart.has(station)) return;
        const item = currentItems.find((it) => String(it.stationNo) === station);
        if (item) {
          cart.set(station, item);
          renderCart();
          fetchStatuses();
        }
      });
      nearbyToggle.addEventListener("change", () => {
        if (addressInput.value.trim()) {
          fetchStatuses();
        }
      });
      radiusInput.addEventListener("change", () => {
        if (addressInput.value.trim() && nearbyToggle.checked) {
          fetchStatuses();
        }
      });

      async function fetchSuggestions(query) {
        if (suggestionAbort) suggestionAbort.abort();
        suggestionAbort = new AbortController();
        const controller = suggestionAbort;
        // Bias to Québec City, allow more results (up to 10) and keep a wider box.
        const center = "-71.2074,46.8139"; // lon,lat roughly Québec City
        const extent = "-71.7,46.6,-70.8,47.1"; // minLon,minLat,maxLon,maxLat
        const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest?f=pjson&maxSuggestions=10&countryCode=CAN&text=${encodeURIComponent(
          query
        )}&location=${center}&searchExtent=${extent}&category=Address,Postal`;
        const res = await fetch(url, { signal: controller.signal });
        if (!res.ok) return [];
        const data = await res.json();
        return data.suggestions || [];
      }

      let suggestTimer = null;
      addressInput.addEventListener("input", (e) => {
        const text = e.target.value.trim();
        selectedSuggestion = null;
        if (suggestTimer) clearTimeout(suggestTimer);
        if (text.length < 3) {
          renderSuggestions([]);
          return;
        }
        suggestTimer = setTimeout(async () => {
          try {
            const suggs = await fetchSuggestions(text);
            renderSuggestions(suggs);
          } catch (err) {
            renderSuggestions([]);
          }
        }, 220);
      });

      suggestionsDiv.addEventListener("click", (e) => {
        const item = e.target.closest(".suggestion-item");
        if (!item) return;
        const text = item.getAttribute("data-text");
        const magicKey = item.getAttribute("data-magic");
        selectedSuggestion = { text, magicKey };
        addressInput.value = text;
        renderSuggestions([]);
        fetchStatuses();
      });

      document.addEventListener("click", (e) => {
        if (!suggestionsDiv.contains(e.target) && e.target !== addressInput) {
          renderSuggestions([]);
        }
      });

      // Hint text on load
      renderStatus("Entre une adresse pour commencer.");

      // Cart rendering
      function renderCart() {
        const list = document.getElementById("cartList");
        const count = document.getElementById("cartCount");
        const subscribeSection = document.getElementById("subscribeSection");
        const subscribeMessage = document.getElementById("subscribeMessage");
        const items = Array.from(cart.values());
        count.textContent = `(${items.length})`;
        if (!items.length) {
          list.innerHTML = '<div class="cart-empty">Faites une sélection pour poursuivre</div>';
          if (subscribeSection) subscribeSection.style.display = "none";
          if (subscribeMessage) subscribeMessage.style.display = "none";
          return;
        }
        if (subscribeSection) subscribeSection.style.display = "flex";
        if (subscribeMessage) subscribeMessage.style.display = "none";
        list.innerHTML = items
          .map(
            (item) => `
          <div class="cart-item" data-station="${item.stationNo}">
            <div>
              <div class="cart-item-title">Poste ${item.stationNo}</div>
              <div class="cart-item-meta">${item.locationLabel || "Emplacement inconnu"}</div>
            </div>
            <button class="cart-remove" data-station="${item.stationNo}">x</button>
          </div>
        `
          )
          .join("");
      }
      document.getElementById("cartList").addEventListener("click", (e) => {
        const btn = e.target.closest(".cart-remove");
        if (!btn) return;
        const station = btn.getAttribute("data-station");
        cart.delete(station);
        renderCart();
        fetchStatuses();
      });

      // Subscription placeholder
      document.getElementById("subscribeButton").addEventListener("click", () => {
        const phone = document.getElementById("phoneInput").value.trim();
        const msg = document.getElementById("subscribeMessage");
        if (!phone) {
          alert("Entre un numéro de téléphone pour t'abonner.");
          return;
        }
        if (msg) {
          const stations = Array.from(cart.keys()).join(", ") || "aucun poste";
          msg.textContent = `Votre abonnement aux postes suivants a été complété avec succès : ${stations}`;
          msg.style.display = "block";
        }
      });
    </script>
  </body>
