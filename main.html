<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Opération tempête</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
        color: #e2e8f0;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 24px;
      }
      .card {
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(226, 232, 240, 0.1);
        border-radius: 16px;
        padding: 24px;
        max-width: 520px;
        width: 100%;
        box-shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
      }
      h1 {
        margin: 0 0 12px 0;
        font-size: 28px;
        letter-spacing: 0.5px;
      }
      p {
        margin: 0 0 18px 0;
        line-height: 1.6;
        color: #cbd5e1;
      }
      button {
        appearance: none;
        border: none;
        border-radius: 10px;
        padding: 12px 18px;
        font-size: 16px;
        font-weight: 600;
        color: #0f172a;
        background: linear-gradient(120deg, #fbbf24, #f59e0b);
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
        width: 100%;
      }
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
        filter: brightness(1.05);
      }
      button:active {
        transform: translateY(0);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
      }
      .note {
        margin-top: 12px;
        font-size: 14px;
        color: #94a3b8;
      }
      .field {
        display: flex;
        gap: 12px;
        margin: 18px 0 8px 0;
        flex-wrap: wrap;
        position: relative;
      }
      .field input {
        flex: 1;
        min-width: 240px;
        padding: 12px 14px;
        border-radius: 10px;
        border: 1px solid rgba(226, 232, 240, 0.2);
        background: rgba(255, 255, 255, 0.06);
        color: #e2e8f0;
        font-size: 16px;
        outline: none;
      }
      .field input:focus {
        border-color: #fbbf24;
        box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.25);
      }
      .suggestions {
        position: absolute;
        top: 56px;
        left: 0;
        right: 0;
        z-index: 5;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(226, 232, 240, 0.12);
        border-radius: 10px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        overflow: hidden;
      }
      .suggestion-item {
        padding: 10px 14px;
        cursor: pointer;
        color: #e2e8f0;
        border-bottom: 1px solid rgba(226, 232, 240, 0.07);
      }
      .suggestion-item:last-child {
        border-bottom: none;
      }
      .suggestion-item:hover {
        background: rgba(226, 232, 240, 0.08);
      }
      .results {
        margin-top: 16px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(226, 232, 240, 0.05);
      }
      .result-item {
        padding: 10px 0;
        border-bottom: 1px solid rgba(226, 232, 240, 0.07);
      }
      .result-item.no-border {
        border-bottom: none;
        padding-bottom: 6px;
      }
      .result-item:last-child {
        border-bottom: none;
      }
      .result-title {
        font-weight: 700;
        color: #f8fafc;
        margin-bottom: 4px;
      }
      .result-meta {
        color: #cbd5e1;
        font-size: 14px;
        line-height: 1.5;
      }
      .divider {
        border-top: 2px solid #fbbf24;
        margin: 8px 0 4px 0;
        opacity: 0.9;
      }
      .options {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 6px;
        color: #cbd5e1;
        font-size: 14px;
      }
      .options input[type="number"] {
        width: 90px;
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(226, 232, 240, 0.2);
        background: rgba(255, 255, 255, 0.06);
        color: #e2e8f0;
      }
      .options input[type="number"]:focus {
        border-color: #fbbf24;
        outline: none;
        box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.2);
      }
      .debug {
        margin-top: 12px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px dashed rgba(226, 232, 240, 0.2);
        font-size: 12px;
        color: #cbd5e1;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>Opération Tempête</h1>
      <p>
        Entre ton adresse (rue, code postal ou no civique) pour voir l’état des
        lumières de déneigement les plus proches (données officielles ArcGIS).
      </p>
      <div class="field">
        <input
          id="addressInput"
          type="text"
          placeholder="Ex.: 121 Avenue Gauvin, Québec G1M 1Y3"
        />
        <button id="statusButton" type="button">Voir le statut</button>
        <div id="suggestions" class="suggestions" style="display: none"></div>
      </div>
      <label class="options">
        <input type="checkbox" id="nearbyToggle" />
        Inclure les feux des rues avoisinantes
        <input
          type="number"
          id="radiusInput"
          min="50"
          max="1000"
          step="50"
          value="200"
          aria-label="Rayon de recherche en mètres"
        />
        <span>m</span>
      </label>
      <div class="results" id="results"></div>
      <div id="debugPanel" class="debug" style="display: none"></div>
    </div>

    <script>
      const DEBUG = false;
      const featureLayerUrl =
        "https://services1.arcgis.com/4GCvRJNX6LNyFVQ0/ArcGIS/rest/services/CI_OPERATION_DENEIGEMENT/FeatureServer/0/query";
      const statusButton = document.getElementById("statusButton");
      const addressInput = document.getElementById("addressInput");
      const resultsDiv = document.getElementById("results");
      const suggestionsDiv = document.getElementById("suggestions");
      const debugPanel = document.getElementById("debugPanel");
      const nearbyToggle = document.getElementById("nearbyToggle");
      const radiusInput = document.getElementById("radiusInput");
      let selectedSuggestion = null;
      let suggestionAbort = null;
      let postsCache = null;
      // Manual overrides: station number -> normalized street name
      const stationStreetMap = {
        "2189": canonicalStreet("avenue gauvin"),
        "2188": canonicalStreet("avenue gauvin"),
        "2185": canonicalStreet("avenue gauvin"),
        "2187": canonicalStreet("avenue gauvin"),
      };
      const allowedStationsByStreet = {
        "avenue gauvin": ["2189", "2188", "2185", "2187"],
      };

      function haversine(lat1, lon1, lat2, lon2) {
        const toRad = (d) => (d * Math.PI) / 180;
        const R = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      function logDebug(title, payload) {
        if (!DEBUG) return;
        const now = new Date().toISOString();
        const existing = debugPanel.textContent
          ? `${debugPanel.textContent}\n`
          : "";
        const content = `${existing}[${now}] ${title}: ${JSON.stringify(
          payload,
          null,
          2
        )}`;
        debugPanel.textContent = content;
        debugPanel.style.display = "block";
        console.info(title, payload);
      }

      async function geocode(queryText, magicKey) {
        const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates?f=pjson&maxLocations=1&singleLine=${encodeURIComponent(
          queryText
        )}${magicKey ? `&magicKey=${encodeURIComponent(magicKey)}` : ""}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Geocodage indisponible");
        const data = await res.json();
        const candidate = data.candidates?.[0];
        if (!candidate) throw new Error("Adresse introuvable");
        logDebug("geocode", {
          address: candidate.address,
          attributes: candidate.attributes,
          location: candidate.location,
        });
        return {
          location: candidate.location, // {x: lon, y: lat}
          address: candidate.address,
          streetHint:
            canonicalStreet(candidate.address) ||
            canonicalStreet(
              candidate.attributes?.StreetName || candidate.attributes?.StName
            ),
        };
      }

      async function projectToSR(points, inSR, outSR) {
        if (!points.length) return [];
        const geometries = encodeURIComponent(
          JSON.stringify({
            geometryType: "esriGeometryPoint",
            geometries: points,
          })
        );
        const url = `https://utility.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer/project?f=pjson&geometries=${geometries}&inSR=${inSR}&outSR=${outSR}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Transformation de coordonnées échouée");
        const data = await res.json();
        logDebug("projectToSR", {
          inSR,
          outSR,
          points,
          resultCount: (data.geometries || []).length,
        });
        return data.geometries || [];
      }

      function normalizeStreet(text) {
        if (!text) return null;
        const base = text
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "");
        const first = base.split(",")[0];
        const cleaned = first
          .replace(/^[0-9-\s]+/, "")
          .replace(/\s+/g, " ")
          .trim();
        return cleaned || null;
      }

      function canonicalStreet(text) {
        const n = normalizeStreet(text);
        if (!n) return null;
        let c = n;
        c = c.replace(/^av(\.|enue)?\s+/, "avenue ");
        c = c.replace(/^ave\s+/, "avenue ");
        c = c.replace(/^av-/ , "avenue ");
        c = c.replace(/^boul(\.|evard)?\s+/, "boulevard ");
        c = c.replace(/^rte\s+/, "route ");
        c = c.replace(/^chem(in)?\s+/, "chemin ");
        c = c.replace(/^r(\.|ue)?\s+/, "rue ");
        c = c.replace(/\s+/g, " ").trim();
        return c;
      }

      function addressOrderKey(post) {
        const street = post.normStreet || "";
        const raw = post.street || "";
        const match = raw.match(/(\d+)/);
        const num = match ? parseInt(match[1], 10) : Number.MAX_SAFE_INTEGER;
        const stationNum = parseInt(post.station, 10);
        return {
          street,
          num,
          station: Number.isNaN(stationNum) ? Number.MAX_SAFE_INTEGER : stationNum,
        };
      }

      async function loadPosts() {
        if (postsCache) return postsCache;
        const res = await fetch("posts.csv");
        if (!res.ok) throw new Error("Impossible de charger le fichier des postes");
        const text = await res.text();
        // CSV parser supporting quoted fields with commas.
        function parseCSV(csvText) {
          const rows = [];
          let row = [];
          let field = "";
          let inQuotes = false;
          for (let i = 0; i < csvText.length; i++) {
            const c = csvText[i];
            if (c === '"' && csvText[i + 1] === '"') {
              field += '"';
              i++; // escaped quote
            } else if (c === '"') {
              inQuotes = !inQuotes;
            } else if (c === "," && !inQuotes) {
              row.push(field);
              field = "";
            } else if ((c === "\n" || c === "\r") && !inQuotes) {
              if (c === "\r" && csvText[i + 1] === "\n") i++;
              row.push(field);
              rows.push(row);
              row = [];
              field = "";
            } else {
              field += c;
            }
          }
          if (field.length > 0 || row.length) {
            row.push(field);
            rows.push(row);
          }
          return rows.filter((r) => r.length);
        }

        const rows = parseCSV(text.trim());
        const header = rows[0];
        const dataRows = rows.slice(1);
        const idx = (name) => header.indexOf(name);
        const stationIdx = idx("STATION_NO");
        const statusIdx = idx("STATUT");
        const dateIdx = idx("DATE_MAJ_ISO");
        const streetIdx = idx("RUE_REVERSE");
        const lonIdx = idx("LON_WGS84");
        const latIdx = idx("LAT_WGS84");

        postsCache = dataRows.map((cols) => {
          const street = cols[streetIdx];
          const lonVal = parseFloat(cols[lonIdx]);
          const latVal = parseFloat(cols[latIdx]);
          return {
            station: cols[stationIdx],
            statut: cols[statusIdx],
            dateMaj: cols[dateIdx],
            street,
            normStreet: canonicalStreet(street),
            lon: Number.isFinite(lonVal) ? lonVal : null,
            lat: Number.isFinite(latVal) ? latVal : null,
          };
        });
        return postsCache;
      }

      const addressCache = new Map();
      async function reverseGeocode4326(point) {
        if (!point) return null;
        const key = `${point.x.toFixed(5)},${point.y.toFixed(5)}`;
        if (addressCache.has(key)) return addressCache.get(key);
        const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?f=pjson&featureTypes=StreetAddress&langCode=fr&location=${point.x},${point.y}`;
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error("reverse geocode failed");
          const data = await res.json();
          const label =
            data.address?.LongLabel ||
            data.address?.Address ||
            data.address?.Match_addr ||
            null;
          addressCache.set(key, label);
          return label;
        } catch (e) {
          addressCache.set(key, null);
          return null;
        }
      }

      function renderSuggestions(list) {
        if (!list.length) {
          suggestionsDiv.style.display = "none";
          suggestionsDiv.innerHTML = "";
          return;
        }
        suggestionsDiv.innerHTML = list
          .map(
            (item) =>
              `<div class="suggestion-item" data-magic="${item.magicKey}" data-text="${item.text}">${item.text}</div>`
          )
          .join("");
        suggestionsDiv.style.display = "block";
      }

      function formatDate(ms) {
        return ms ? new Date(ms).toLocaleString("fr-CA") : "N/D";
      }

      function formatMeters(m) {
        if (m == null) return "distance inconnue";
        if (m >= 1000) return `${(m / 1000).toFixed(1)} km`;
        return `${Math.round(m)} m`;
      }

      function renderStatus(message, items = []) {
        if (!items.length) {
          resultsDiv.innerHTML = `<p class="note">${message}</p>`;
          return;
        }
        let html = "";
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const next = items[i + 1];
          const classNames =
            next && next.group !== item.group
              ? "result-item no-border"
              : "result-item";
          html += `
            <div class="${classNames}">
              <div class="result-title">Feu ${item.statut}</div>
              <div class="result-meta">
                Poste : ${item.stationNo ?? "N/D"} — Distance : ${item.distance}
                <br />
                Emplacement : ${item.locationLabel}
                <br />
                Dernière mise à jour : ${item.updated}
              </div>
            </div>
          `;
          if (next && next.group !== item.group) {
            html += `<div class="divider"></div>`;
          }
        }
        resultsDiv.innerHTML = html;
      }

      async function fetchStatuses() {
        const query = addressInput.value.trim();
        if (!query) {
          renderStatus("Entre une adresse ou un code postal.");
          return;
        }
        renderStatus("Recherche en cours...");
        statusButton.disabled = true;
        try {
          const normalizedInput = canonicalStreet(query);
          const includeNearby = nearbyToggle.checked;
          const radiusMeters = Math.max(
            50,
            Math.min(
              1000,
              Number.parseInt(radiusInput.value, 10) || 200
            )
          );
          const posts = await loadPosts();

          let address = query;
          let location = null;
          try {
            const geo = await geocode(query, selectedSuggestion?.magicKey);
            address = geo.address;
            location = geo.location; // {x: lon, y: lat}
          } catch (e) {
            console.warn("Geocode failed, fallback to street-only", e);
          }

          let filtered = posts.filter((p) => p.normStreet === normalizedInput);

          if (includeNearby && location) {
            const buffer = radiusMeters; // meters
            const nearby = posts.filter((p) => {
              if (!p.lon || !p.lat) return false;
              const d = haversine(location.y, location.x, p.lat, p.lon);
              return d <= buffer;
            });
            const merged = new Map();
            [...filtered, ...nearby].forEach((p) => merged.set(p.station, p));
            filtered = Array.from(merged.values());
          }

          if (!filtered.length) {
            renderStatus(
              `Aucun feu trouvé pour “${address}”. Essaie d'entrer le nom complet de la rue.`
            );
            return;
          }

          // Separate primary street vs nearby
          const primary = filtered.filter((p) => p.normStreet === normalizedInput);
          const others = filtered.filter((p) => p.normStreet !== normalizedInput);

          const sortByAddress = (list) =>
            list.sort((a, b) => {
              const ka = addressOrderKey(a);
              const kb = addressOrderKey(b);
              if (ka.street !== kb.street) return ka.street.localeCompare(kb.street);
              if (ka.num !== kb.num) return ka.num - kb.num;
              return ka.station - kb.station;
            });

          sortByAddress(primary);
          sortByAddress(others);

          const toItems = (list, group) =>
            list.map((p) => {
              const statut = (p.statut || "Inconnu").toLowerCase();
              const updated = p.dateMaj ? p.dateMaj : "N/D";
              const distance =
                location && p.lon && p.lat
                  ? formatMeters(haversine(location.y, location.x, p.lat, p.lon))
                  : "N/D";
              return {
                statut,
                updated,
                stationNo: p.station,
                distance,
                locationLabel: p.street || "emplacement inconnu",
                group,
              };
            });

          const items = [...toItems(others, "nearby"), ...toItems(primary, "primary")];

          renderStatus(`Adresse : ${address}.`, items);
        } catch (error) {
          renderStatus(
            "Impossible de récupérer le statut pour le moment. Réessaie plus tard ou vérifie l’adresse."
          );
          console.error(error);
        } finally {
          statusButton.disabled = false;
        }
      }

      statusButton.addEventListener("click", fetchStatuses);
      addressInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          fetchStatuses();
        }
      });
      nearbyToggle.addEventListener("change", () => {
        if (addressInput.value.trim()) {
          fetchStatuses();
        }
      });
      radiusInput.addEventListener("change", () => {
        if (addressInput.value.trim() && nearbyToggle.checked) {
          fetchStatuses();
        }
      });

      async function fetchSuggestions(query) {
        if (suggestionAbort) suggestionAbort.abort();
        suggestionAbort = new AbortController();
        const controller = suggestionAbort;
        // Bias to Québec City, allow more results (up to 10) and keep a wider box.
        const center = "-71.2074,46.8139"; // lon,lat roughly Québec City
        const extent = "-71.7,46.6,-70.8,47.1"; // minLon,minLat,maxLon,maxLat
        const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest?f=pjson&maxSuggestions=10&countryCode=CAN&text=${encodeURIComponent(
          query
        )}&location=${center}&searchExtent=${extent}&category=Address,Postal`;
        const res = await fetch(url, { signal: controller.signal });
        if (!res.ok) return [];
        const data = await res.json();
        return data.suggestions || [];
      }

      let suggestTimer = null;
      addressInput.addEventListener("input", (e) => {
        const text = e.target.value.trim();
        selectedSuggestion = null;
        if (suggestTimer) clearTimeout(suggestTimer);
        if (text.length < 3) {
          renderSuggestions([]);
          return;
        }
        suggestTimer = setTimeout(async () => {
          try {
            const suggs = await fetchSuggestions(text);
            renderSuggestions(suggs);
          } catch (err) {
            renderSuggestions([]);
          }
        }, 220);
      });

      suggestionsDiv.addEventListener("click", (e) => {
        const item = e.target.closest(".suggestion-item");
        if (!item) return;
        const text = item.getAttribute("data-text");
        const magicKey = item.getAttribute("data-magic");
        selectedSuggestion = { text, magicKey };
        addressInput.value = text;
        renderSuggestions([]);
        fetchStatuses();
      });

      document.addEventListener("click", (e) => {
        if (!suggestionsDiv.contains(e.target) && e.target !== addressInput) {
          renderSuggestions([]);
        }
      });

      // Hint text on load
      renderStatus("Entre une adresse pour commencer.");
    </script>
  </body>
</html>
